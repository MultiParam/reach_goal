一直在看数学的东西，但是数据结构与算法还是不要辜负。

看了看 labuladong 的算法小抄，建议刷题可以从树开始刷，那么就开始看树的内容。

# 树一些概念

父节点：画图好理解，`E` 是 `A` 的父节点。

子节点：画图好理解，`A` 是 `E` 的子节点。

兄弟节点：同一个父节点的子节点，互相为兄弟节点。

叶子节点：没有子节点的节点。

根节点：没有父节点的节点。

高度：从下往上的感觉。叶子节点到此节点的最大路径(最多边)

深度：从上而下的感觉。根节点到此节点的最大路径.

层：深度 + 1

树的高度：根节点的高度

![树图](http://img.multiparam.com/dapao/code/20200903022251.png)

所以以 F 为例。

```
F 的父节点是 E。
F 的兄弟节点是 A。
F 的子节点是 K,L。
F 的高度是 1。
F 的深度是 1。
F 的层是 1。
```

# 二叉树

二叉树就是最多只有两个左右节点，所以可以只有左或者右节点。

二叉树还有两种特殊情况：满二叉树和完全二叉树。

满二叉树是很好理解的，就是除了叶子节点，各节点都拥有左右子节点。

那么完全二叉树是什么？完全二叉树其实与顺序存储方式有关联，所以单拎出来。

完全二叉树是最后一层的子节点都靠左排列，其余层节点的个数要达到最大的树。



## 二叉树链式存储与顺序存储

一般来说都是链式存储，盗个图看看就知道了。

![](http://img.multiparam.com/dapao/code/20200903025058.png)

看一下顺序存储：给每个节点按照完全二叉树的方式编号，然后依次存入数组。如果根节点在 i = 1 的位置。那么他的左右节点便是 2i 和 2i + 1 的位置。而一个节点的父节点位置便是 i / 2。

这个方式如果不是完全二叉树方式的话，会浪费很多空间，这就是完全二叉树的优势了。



## 二叉树的遍历

其实都是 x 序遍历。这个序，就是一个树的根节点在遍历中的顺序。

前序遍历：树的任意节点来说，先遍历这个节点，再去左子树，后右子树。根，左，右

中序遍历：树的任意节点来说，先遍历这个节点的左子树，再这个节点，再右子树。左，根，右

后序遍历：树的任意节点来说，先遍历这个节点的左子树，再右子树，再这个节点，左，右，根

层序遍历：根据树的一层一层遍历。

时间复杂度：O(n)。因为每个节点最多遍历两次，所以与节点个数 n 成正比。



# 二叉查找树

二叉查找树是一种支持快速查找，删除插入的数据结构。而它的特点便是任意节点的左子树都比这个节点的值小，右子树的节点值都比这个节点大。

而快速查找还有一个结构就是散列表，这个需要做一些比较，不过先把二叉查找树的东西写一下。

主要操作分为查找，插入，删除，快速查找最大节点，最小节点，前驱后继节点。

## 查找

查找其实挺好理解。其实也就是不断地递归遍历，如果遍历节点比要找的值大，就遍历左子树；如果遍历节点比要找的值小，就遍历右子树。

## 插入

其实和查找也差不多，插入值大于当前值， 遍历右子树；插入值小于当前值，遍历左子树，直到找到一个叶子节点。

## 删除

删除应该是比较麻烦的。删除节点要分情况，根据 **删除节点的子节点个数来区分**。

1. 没有子节点

    直接删除。

2. 一个子节点

    删除节点的父节点，原本指向此节点的指针，指向此节点的子节点。

3. 两个子节点

    其实就是要找一个比删除节点的左子树都大，但比删除节点的右子树都小的节点来替代这个位置。所以去遍历此节点的右子树的最小节点，也就是会遍历其左子树的叶子节点，替换值后，还要删除这个最小节点。这个最小节点一定只有右节点或者就没有子节点，可以利用第一二个规则去删除。

当然，假删除也是可以的。

## 中序遍历

二叉查找树的中序遍历就是有序数据序列，时间复杂度 O(n)。

## 各操作的时间复杂度

这个与二叉查找树形状有关系，要是形状是只有单边的子节点，就退化成 O(n) 了。

拿理想状态来看，也就是一个完全二叉树或满二叉树。我们可以发现，其实时间复杂度和树的高度成正比，那么只要知道 n 个节点的完全二叉树的高度怎么计算就好了。

完全二叉树第 k 层节点数为 2 ^ (k - 1)。最后一层则是 [2 ^( k - 2) + 1, 2 ^ (k - 1)] 之间。所以 n 满足这样的关系式

```
n >= 1+2+4+8+...+2^(k-2)+1
n <= 1+2+4+8+...+2^(k-2)+2^(k-1)
```

根据等比数列求和公式，可以求得 k 的范围是 [log2(n+1), log2n +1]. 也就是说，层数范围是这么多。而树高度 = 层数 - 1，所以时间复杂度大致是 O(logN)。

所以我们肯定希望树的形状能尽量保持完全二叉或者近似完全二叉形状的树，叫做 **保持平衡**。所以才会有了平衡二叉查找树，对应的还有工业上常用的红黑树。



## 和散列表的区分

1.  散列表的数据无序存储，需要输出有序的数据得排序。而二叉查找直接中序遍历，O(n) 完成。
2. 散列表扩容耗时大，而且遇到散列冲突也不稳定。但平衡二叉查找树是比较稳定的。
3. 散列表查找的时间复杂度是常数级别。但是为了应对哈希冲突，不一定更快。
4. 散列表的构造较为麻烦，考虑散列函数设计，冲突解决，扩容缩容。而二叉查找，主要考虑保持平衡性。

# 需要完成

1. 前中后层序遍历实现
2. 二叉查找树的概念学习，实现
3. 树的高度如何求。
